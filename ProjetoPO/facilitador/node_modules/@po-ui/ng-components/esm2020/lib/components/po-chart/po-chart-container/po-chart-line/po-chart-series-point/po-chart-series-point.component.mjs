import { __decorate } from "tslib";
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { from, timer } from 'rxjs';
import { concatMap, mapTo, scan, tap } from 'rxjs/operators';
import { isIE } from '../../../../../utils/util';
import { InputBoolean } from '../../../../../decorators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "../../../../../directives/po-tooltip/po-tooltip.directive";
const _c0 = ["po-chart-series-point", ""];
function PoChartSeriesPointComponent__svg_circle_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = i0.ɵɵgetCurrentView();
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "circle", 1);
    i0.ɵɵlistener("click", function PoChartSeriesPointComponent__svg_circle_0_Template__svg_circle_click_0_listener() { const restoredCtx = i0.ɵɵrestoreView(_r3); const item_r1 = restoredCtx.$implicit; const ctx_r2 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r2.onClick(item_r1)); })("mouseenter", function PoChartSeriesPointComponent__svg_circle_0_Template__svg_circle_mouseenter_0_listener($event) { const restoredCtx = i0.ɵɵrestoreView(_r3); const item_r1 = restoredCtx.$implicit; const ctx_r4 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r4.onMouseEnter($event, item_r1)); })("mouseleave", function PoChartSeriesPointComponent__svg_circle_0_Template__svg_circle_mouseleave_0_listener($event) { i0.ɵɵrestoreView(_r3); const ctx_r5 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r5.onMouseLeave($event)); });
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMap((ctx_r0.strokeColor == null ? null : ctx_r0.strokeColor.includes("po-border-color")) ? ctx_r0.strokeColor : "");
    i0.ɵɵclassProp("po-chart-active-point", item_r1.isActive);
    i0.ɵɵproperty("p-tooltip", item_r1.tooltipLabel)("p-append-in-body", true)("p-display-tooltip", !ctx_r0.chartLine && item_r1.isActive);
    i0.ɵɵattribute("cx", item_r1.xCoordinate)("cy", item_r1.yCoordinate)("r", ctx_r0.radius)("stroke", ctx_r0.strokeColor);
} }
const RADIUS_DEFAULT_SIZE = 5;
const RADIUS_HOVER_SIZE = 10;
const ANIMATION_DURATION_TIME = 700;
export class PoChartSeriesPointComponent {
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.chartLine = false;
        this.pointClick = new EventEmitter();
        this.pointHover = new EventEmitter();
        this.radius = RADIUS_DEFAULT_SIZE;
        this._coordinates = [];
        this.animationState = true;
    }
    set color(value) {
        this.strokeColor = value.includes('po-color') ? value.replace('po-color', 'po-border-color') : value;
        this._color = value;
    }
    get color() {
        return this._color;
    }
    set coordinates(value) {
        this._coordinates = value;
        this.coordinates$ = this.displayPointsWithDelay(this._coordinates);
    }
    get coordinates() {
        return this._coordinates;
    }
    trackBy(index) {
        return index;
    }
    onClick(point) {
        const selectedItem = { label: point.label, data: point.data, category: point.category };
        this.pointClick.emit(selectedItem);
    }
    onMouseEnter(event, point) {
        this.setPointAttribute(event.target, true);
        const selectedItem = { label: point.label, data: point.data, category: point.category };
        this.pointHover.emit({ relativeTo: this.relativeTo, ...selectedItem });
    }
    onMouseLeave(event) {
        this.setPointAttribute(event.target, false);
    }
    displayPointsWithDelay(coordinates) {
        if (this.animationState && !isIE()) {
            const animationTimer = ANIMATION_DURATION_TIME / coordinates.length;
            return from(coordinates).pipe(concatMap((item, index) => timer(index === 0 || !this.animate ? 0 : animationTimer).pipe(mapTo(item))), scan((acc, curr) => acc.concat(curr), []), tap(() => (this.animationState = false)));
        }
        else {
            return from([coordinates]);
        }
    }
    setPointAttribute(target, isHover) {
        this.renderer.setAttribute(target, 'r', isHover ? RADIUS_HOVER_SIZE.toString() : RADIUS_DEFAULT_SIZE.toString());
        if (this.color.includes('po-color')) {
            this.renderer.setAttribute(target, 'class', isHover ? `${this.strokeColor} ${this.color}` : `po-chart-line-point po-chart-active-point ${this.strokeColor}`);
        }
        else {
            this.renderer[isHover ? 'setStyle' : 'removeStyle'](target, 'fill', isHover ? this.color : undefined);
        }
    }
}
PoChartSeriesPointComponent.ɵfac = function PoChartSeriesPointComponent_Factory(t) { return new (t || PoChartSeriesPointComponent)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef)); };
PoChartSeriesPointComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: PoChartSeriesPointComponent, selectors: [["", "po-chart-series-point", ""]], inputs: { animate: ["p-animate", "animate"], isActive: ["p-is-active", "isActive"], chartLine: ["p-chart-line", "chartLine"], relativeTo: ["p-relative-to", "relativeTo"], color: ["p-color", "color"], coordinates: ["p-coordinates", "coordinates"] }, outputs: { pointClick: "p-point-click", pointHover: "p-point-hover" }, attrs: _c0, decls: 2, vars: 4, consts: [["p-tooltip-position", "top", "class", "po-chart-line-point", 3, "p-tooltip", "p-append-in-body", "p-display-tooltip", "class", "po-chart-active-point", "click", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["p-tooltip-position", "top", 1, "po-chart-line-point", 3, "p-tooltip", "p-append-in-body", "p-display-tooltip", "click", "mouseenter", "mouseleave"]], template: function PoChartSeriesPointComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, PoChartSeriesPointComponent__svg_circle_0_Template, 1, 11, "circle", 0);
        i0.ɵɵpipe(1, "async");
    } if (rf & 2) {
        i0.ɵɵproperty("ngForOf", i0.ɵɵpipeBind1(1, 2, ctx.coordinates$))("ngForTrackBy", ctx.trackBy);
    } }, dependencies: [i1.NgForOf, i2.PoTooltipDirective, i1.AsyncPipe], encapsulation: 2 });
__decorate([
    InputBoolean()
], PoChartSeriesPointComponent.prototype, "isActive", void 0);
__decorate([
    InputBoolean()
], PoChartSeriesPointComponent.prototype, "chartLine", void 0);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PoChartSeriesPointComponent, [{
        type: Component,
        args: [{ selector: '[po-chart-series-point]', template: "<svg:circle *ngFor=\"let item of coordinates$ | async; trackBy: trackBy\" \n  [p-tooltip]=\"item.tooltipLabel\"\n  [p-append-in-body]='true'\n  [p-display-tooltip]=\"!chartLine && item.isActive\"\n  p-tooltip-position=\"top\"\n  class=\"po-chart-line-point\"\n  [class]=\"strokeColor?.includes('po-border-color') ? strokeColor : ''\"\n  [class.po-chart-active-point]=\"item.isActive\"\n  [attr.cx]=\"item.xCoordinate\"\n  [attr.cy]=\"item.yCoordinate\"\n  [attr.r]=\"radius\"\n  [attr.stroke]=\"strokeColor\"\n  (click)=\"onClick(item)\"\n  (mouseenter)=\"onMouseEnter($event, item)\"\n  (mouseleave)=\"onMouseLeave($event)\"\n  >\n</svg:circle>\n" }]
    }], function () { return [{ type: i0.Renderer2 }, { type: i0.ElementRef }]; }, { animate: [{
            type: Input,
            args: ['p-animate']
        }], isActive: [{
            type: Input,
            args: ['p-is-active']
        }], chartLine: [{
            type: Input,
            args: ['p-chart-line']
        }], relativeTo: [{
            type: Input,
            args: ['p-relative-to']
        }], pointClick: [{
            type: Output,
            args: ['p-point-click']
        }], pointHover: [{
            type: Output,
            args: ['p-point-hover']
        }], color: [{
            type: Input,
            args: ['p-color']
        }], coordinates: [{
            type: Input,
            args: ['p-coordinates']
        }] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtc2VyaWVzLXBvaW50LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1jaGFydC9wby1jaGFydC1jb250YWluZXIvcG8tY2hhcnQtbGluZS9wby1jaGFydC1zZXJpZXMtcG9pbnQvcG8tY2hhcnQtc2VyaWVzLXBvaW50LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1jaGFydC9wby1jaGFydC1jb250YWluZXIvcG8tY2hhcnQtbGluZS9wby1jaGFydC1zZXJpZXMtcG9pbnQvcG8tY2hhcnQtc2VyaWVzLXBvaW50LmNvbXBvbmVudC5zdmciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQWMsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFDOUYsT0FBTyxFQUFFLElBQUksRUFBYyxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTdELE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNqRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7Ozs7Ozs7SUNMekQsbUJBZUc7SUFmSCxpQ0FlRztJQUhELGdQQUFTLGVBQUEsdUJBQWEsQ0FBQSxJQUFDLG1QQUNULGVBQUEsb0NBQTBCLENBQUEsSUFEakIsd0xBRVQsZUFBQSwyQkFBb0IsQ0FBQSxJQUZYO0lBSXpCLGlCQUFhOzs7O0lBVlgsNkhBQXFFO0lBQ3JFLHlEQUE2QztJQU43QyxnREFBK0IsMEJBQUEsNERBQUE7SUFPL0IseUNB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QyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDdkc7SUFDSCxDQUFDOztzR0E1RlUsMkJBQTJCOzhFQUEzQiwyQkFBMkI7UUNqQnhDLHdGQWdCYTs7O1FBaEJnQixnRUFBeUIsNkJBQUE7O0FEb0JkO0lBQWYsWUFBWSxFQUFFOzZEQUFtQjtBQUVqQjtJQUFmLFlBQVksRUFBRTs4REFBNEI7dUZBTHZELDJCQUEyQjtjQUp2QyxTQUFTOzJCQUNFLHlCQUF5QjtxRkFJZixPQUFPO2tCQUExQixLQUFLO21CQUFDLFdBQVc7WUFFb0IsUUFBUTtrQkFBN0MsS0FBSzttQkFBQyxhQUFhO1lBRW1CLFNBQVM7a0JBQS9DLEtBQUs7bUJBQUMsY0FBYztZQUdHLFVBQVU7a0JBQWpDLEtBQUs7bUJBQUMsZUFBZTtZQUVHLFVBQVU7a0JBQWxDLE1BQU07bUJBQUMsZUFBZTtZQUVFLFVBQVU7a0JBQWxDLE1BQU07bUJBQUMsZUFBZTtZQVdELEtBQUs7a0JBQTFCLEtBQUs7bUJBQUMsU0FBUztZQVNZLFdBQVc7a0JBQXRDLEtBQUs7bUJBQUMsZUFBZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb20sIE9ic2VydmFibGUsIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjb25jYXRNYXAsIG1hcFRvLCBzY2FuLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IGlzSUUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlscy91dGlsJztcbmltcG9ydCB7IElucHV0Qm9vbGVhbiB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2RlY29yYXRvcnMnO1xuXG5pbXBvcnQgeyBQb0NoYXJ0UG9pbnRzQ29vcmRpbmF0ZXMgfSBmcm9tICcuLi8uLi8uLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LXBvaW50cy1jb29yZGluYXRlcy5pbnRlcmZhY2UnO1xuXG5jb25zdCBSQURJVVNfREVGQVVMVF9TSVpFID0gNTtcbmNvbnN0IFJBRElVU19IT1ZFUl9TSVpFID0gMTA7XG5jb25zdCBBTklNQVRJT05fRFVSQVRJT05fVElNRSA9IDcwMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW3BvLWNoYXJ0LXNlcmllcy1wb2ludF0nLFxuICB0ZW1wbGF0ZVVybDogJy4vcG8tY2hhcnQtc2VyaWVzLXBvaW50LmNvbXBvbmVudC5zdmcnXG59KVxuZXhwb3J0IGNsYXNzIFBvQ2hhcnRTZXJpZXNQb2ludENvbXBvbmVudCB7XG4gIEBJbnB1dCgncC1hbmltYXRlJykgYW5pbWF0ZTogYm9vbGVhbjtcblxuICBASW5wdXQoJ3AtaXMtYWN0aXZlJykgQElucHV0Qm9vbGVhbigpIGlzQWN0aXZlOiBib29sZWFuO1xuXG4gIEBJbnB1dCgncC1jaGFydC1saW5lJykgQElucHV0Qm9vbGVhbigpIGNoYXJ0TGluZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIFJlZmVyw6puY2lhIHBhcmEgbyBzdmdQYXRoR3JvdXAgYW8gcXVhbCBwZXJ0ZW5jZSBvIHBvbnRvLiBOZWNlc3PDoXJpbyBwYXJhIHJlb3JkZW5hw6fDo28gZG9zIHN2Z0VsZW1lbnRzIG5vIERPTSBwYXJhIHRyYXRhbWVudG8gb25Ib3ZlclxuICBASW5wdXQoJ3AtcmVsYXRpdmUtdG8nKSByZWxhdGl2ZVRvOiBzdHJpbmc7XG5cbiAgQE91dHB1dCgncC1wb2ludC1jbGljaycpIHBvaW50Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICBAT3V0cHV0KCdwLXBvaW50LWhvdmVyJykgcG9pbnRIb3ZlciA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIGNvb3JkaW5hdGVzJDogT2JzZXJ2YWJsZTxBcnJheTxQb0NoYXJ0UG9pbnRzQ29vcmRpbmF0ZXM+PjtcbiAgcmFkaXVzOiBudW1iZXIgPSBSQURJVVNfREVGQVVMVF9TSVpFO1xuICBzdHJva2VDb2xvcjogc3RyaW5nO1xuXG4gIHByaXZhdGUgX2NvbG9yOiBzdHJpbmc7XG4gIHByaXZhdGUgX2Nvb3JkaW5hdGVzOiBBcnJheTxQb0NoYXJ0UG9pbnRzQ29vcmRpbmF0ZXM+ID0gW107XG5cbiAgcHJpdmF0ZSBhbmltYXRpb25TdGF0ZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgQElucHV0KCdwLWNvbG9yJykgc2V0IGNvbG9yKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gdmFsdWUuaW5jbHVkZXMoJ3BvLWNvbG9yJykgPyB2YWx1ZS5yZXBsYWNlKCdwby1jb2xvcicsICdwby1ib3JkZXItY29sb3InKSA6IHZhbHVlO1xuICAgIHRoaXMuX2NvbG9yID0gdmFsdWU7XG4gIH1cblxuICBnZXQgY29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICB9XG5cbiAgQElucHV0KCdwLWNvb3JkaW5hdGVzJykgc2V0IGNvb3JkaW5hdGVzKHZhbHVlOiBBcnJheTxQb0NoYXJ0UG9pbnRzQ29vcmRpbmF0ZXM+KSB7XG4gICAgdGhpcy5fY29vcmRpbmF0ZXMgPSB2YWx1ZTtcblxuICAgIHRoaXMuY29vcmRpbmF0ZXMkID0gdGhpcy5kaXNwbGF5UG9pbnRzV2l0aERlbGF5KHRoaXMuX2Nvb3JkaW5hdGVzKTtcbiAgfVxuXG4gIGdldCBjb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXM7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cblxuICB0cmFja0J5KGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgb25DbGljayhwb2ludDogUG9DaGFydFBvaW50c0Nvb3JkaW5hdGVzKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRJdGVtID0geyBsYWJlbDogcG9pbnQubGFiZWwsIGRhdGE6IHBvaW50LmRhdGEsIGNhdGVnb3J5OiBwb2ludC5jYXRlZ29yeSB9O1xuXG4gICAgdGhpcy5wb2ludENsaWNrLmVtaXQoc2VsZWN0ZWRJdGVtKTtcbiAgfVxuXG4gIG9uTW91c2VFbnRlcihldmVudDogYW55LCBwb2ludDogUG9DaGFydFBvaW50c0Nvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5zZXRQb2ludEF0dHJpYnV0ZShldmVudC50YXJnZXQsIHRydWUpO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRJdGVtID0geyBsYWJlbDogcG9pbnQubGFiZWwsIGRhdGE6IHBvaW50LmRhdGEsIGNhdGVnb3J5OiBwb2ludC5jYXRlZ29yeSB9O1xuICAgIHRoaXMucG9pbnRIb3Zlci5lbWl0KHsgcmVsYXRpdmVUbzogdGhpcy5yZWxhdGl2ZVRvLCAuLi5zZWxlY3RlZEl0ZW0gfSk7XG4gIH1cblxuICBvbk1vdXNlTGVhdmUoZXZlbnQ6IGFueSkge1xuICAgIHRoaXMuc2V0UG9pbnRBdHRyaWJ1dGUoZXZlbnQudGFyZ2V0LCBmYWxzZSk7XG4gIH1cblxuICBwcml2YXRlIGRpc3BsYXlQb2ludHNXaXRoRGVsYXkoXG4gICAgY29vcmRpbmF0ZXM6IEFycmF5PFBvQ2hhcnRQb2ludHNDb29yZGluYXRlcz5cbiAgKTogT2JzZXJ2YWJsZTxBcnJheTxQb0NoYXJ0UG9pbnRzQ29vcmRpbmF0ZXM+PiB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uU3RhdGUgJiYgIWlzSUUoKSkge1xuICAgICAgY29uc3QgYW5pbWF0aW9uVGltZXIgPSBBTklNQVRJT05fRFVSQVRJT05fVElNRSAvIGNvb3JkaW5hdGVzLmxlbmd0aDtcblxuICAgICAgcmV0dXJuIGZyb20oY29vcmRpbmF0ZXMpLnBpcGUoXG4gICAgICAgIGNvbmNhdE1hcCgoaXRlbSwgaW5kZXgpID0+IHRpbWVyKGluZGV4ID09PSAwIHx8ICF0aGlzLmFuaW1hdGUgPyAwIDogYW5pbWF0aW9uVGltZXIpLnBpcGUobWFwVG8oaXRlbSkpKSxcbiAgICAgICAgc2NhbigoYWNjLCBjdXJyOiBQb0NoYXJ0UG9pbnRzQ29vcmRpbmF0ZXMpID0+IGFjYy5jb25jYXQoY3VyciksIFtdKSxcbiAgICAgICAgdGFwKCgpID0+ICh0aGlzLmFuaW1hdGlvblN0YXRlID0gZmFsc2UpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZyb20oW2Nvb3JkaW5hdGVzXSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRQb2ludEF0dHJpYnV0ZSh0YXJnZXQ6IFNWR0VsZW1lbnQsIGlzSG92ZXI6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0YXJnZXQsICdyJywgaXNIb3ZlciA/IFJBRElVU19IT1ZFUl9TSVpFLnRvU3RyaW5nKCkgOiBSQURJVVNfREVGQVVMVF9TSVpFLnRvU3RyaW5nKCkpO1xuICAgIGlmICh0aGlzLmNvbG9yLmluY2x1ZGVzKCdwby1jb2xvcicpKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICAnY2xhc3MnLFxuICAgICAgICBpc0hvdmVyID8gYCR7dGhpcy5zdHJva2VDb2xvcn0gJHt0aGlzLmNvbG9yfWAgOiBgcG8tY2hhcnQtbGluZS1wb2ludCBwby1jaGFydC1hY3RpdmUtcG9pbnQgJHt0aGlzLnN0cm9rZUNvbG9yfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXJbaXNIb3ZlciA/ICdzZXRTdHlsZScgOiAncmVtb3ZlU3R5bGUnXSh0YXJnZXQsICdmaWxsJywgaXNIb3ZlciA/IHRoaXMuY29sb3IgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxufVxuIiwiPHN2ZzpjaXJjbGUgKm5nRm9yPVwibGV0IGl0ZW0gb2YgY29vcmRpbmF0ZXMkIHwgYXN5bmM7IHRyYWNrQnk6IHRyYWNrQnlcIiBcbiAgW3AtdG9vbHRpcF09XCJpdGVtLnRvb2x0aXBMYWJlbFwiXG4gIFtwLWFwcGVuZC1pbi1ib2R5XT0ndHJ1ZSdcbiAgW3AtZGlzcGxheS10b29sdGlwXT1cIiFjaGFydExpbmUgJiYgaXRlbS5pc0FjdGl2ZVwiXG4gIHAtdG9vbHRpcC1wb3NpdGlvbj1cInRvcFwiXG4gIGNsYXNzPVwicG8tY2hhcnQtbGluZS1wb2ludFwiXG4gIFtjbGFzc109XCJzdHJva2VDb2xvcj8uaW5jbHVkZXMoJ3BvLWJvcmRlci1jb2xvcicpID8gc3Ryb2tlQ29sb3IgOiAnJ1wiXG4gIFtjbGFzcy5wby1jaGFydC1hY3RpdmUtcG9pbnRdPVwiaXRlbS5pc0FjdGl2ZVwiXG4gIFthdHRyLmN4XT1cIml0ZW0ueENvb3JkaW5hdGVcIlxuICBbYXR0ci5jeV09XCJpdGVtLnlDb29yZGluYXRlXCJcbiAgW2F0dHIucl09XCJyYWRpdXNcIlxuICBbYXR0ci5zdHJva2VdPVwic3Ryb2tlQ29sb3JcIlxuICAoY2xpY2spPVwib25DbGljayhpdGVtKVwiXG4gIChtb3VzZWVudGVyKT1cIm9uTW91c2VFbnRlcigkZXZlbnQsIGl0ZW0pXCJcbiAgKG1vdXNlbGVhdmUpPVwib25Nb3VzZUxlYXZlKCRldmVudClcIlxuICA+XG48L3N2ZzpjaXJjbGU+XG4iXX0=