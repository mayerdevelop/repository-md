import { Component, Input } from '@angular/core';
import { PoGaugePointerEnd, PoGaugeThickness, poGaugeTotalValueDefault } from '../po-gauge-default-values.constant';
import { PoDefaultColors } from '../../../services/po-color/po-colors.constant';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./po-gauge-path/po-gauge-path.component";
import * as i3 from "./po-gauge-pointer/po-gauge-pointer.component";
function PoGaugeSvgComponent__svg_svg_0__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    const ctx_r1 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("p-coordinates", ctx_r1.pointerCoordinates);
} }
function PoGaugeSvgComponent__svg_svg_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "svg", 1);
    i0.ɵɵelement(1, "g", 2);
    i0.ɵɵtemplate(2, PoGaugeSvgComponent__svg_svg_0__svg_g_2_Template, 1, 1, "g", 3);
    i0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵattribute("viewBox", ctx_r0.viewBox)("height", ctx_r0.container == null ? null : ctx_r0.container.height);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("p-base-coordinates", ctx_r0.baseCoordinates)("p-ranges-coordinates", ctx_r0.coordinates);
    i0.ɵɵadvance(1);
    i0.ɵɵproperty("ngIf", ctx_r0.hasRanges);
} }
export const poGaugeStartAngle = -Math.PI;
export class PoGaugeSvgComponent {
    constructor() {
        this.addSvgElement = false;
    }
    get hasRanges() {
        return this.ranges.length > 0;
    }
    ngOnChanges(changes) {
        if ((this.container && changes.value) || (this.container && changes.ranges) || this.container) {
            this.setCoordinates(this.value, this.ranges, this.container);
        }
    }
    setCoordinates(value, ranges, container) {
        const { height } = container;
        // Adiciona elemento svg somente após calcular a altura do container pois o svg tem altura default de 150px.
        this.addSvgElement = true;
        this.setViewBox(height);
        this.setBaseCoordinates(height);
        if (!ranges.length) {
            this.setSingleRangeCoordinates(height, value);
            return;
        }
        this.setRangesCoordinates(height, value, ranges);
    }
    setBaseCoordinates(height) {
        const endAngleRadian = 0;
        const coordinates = this.calculateCoordinates(height, poGaugeStartAngle, endAngleRadian);
        this.baseCoordinates = { coordinates };
    }
    setRangesCoordinates(height, value = 0, ranges) {
        const { minRange, maxRange } = this.calculateMinAndMaxValues(ranges);
        const minValue = value < minRange ? value : minRange;
        const maxValue = value > maxRange ? value : maxRange;
        this.setPointerCoordinates(height, value, maxValue, minValue);
        // `.reverse()` no término da iteração para tratar a sobreposicão correta das bordas arredondadas dos ranges.
        const rangesCoordinates = ranges
            .map((range) => {
            const from = range.from ?? 0;
            const to = range.to ?? maxRange;
            const startAngleRadian = poGaugeStartAngle + this.calculateAngleRadius(from, maxValue, minValue);
            const endAngleRadian = poGaugeStartAngle + this.calculateAngleRadius(to, maxValue, minValue);
            const coordinates = this.calculateCoordinates(height, startAngleRadian, endAngleRadian);
            return { coordinates, color: range.color };
        })
            .reverse();
        this.coordinates = rangesCoordinates;
    }
    setSingleRangeCoordinates(height, value) {
        const verifiedValue = value > 100 ? 100 : value;
        const endAngleRadian = poGaugeStartAngle + this.calculateAngleRadius(verifiedValue, poGaugeTotalValueDefault);
        const coordinates = value > 0 ? this.calculateCoordinates(height, poGaugeStartAngle, endAngleRadian) : undefined;
        const color = PoDefaultColors[0][0];
        this.coordinates = [{ coordinates, color }];
    }
    setPointerCoordinates(height, value, maxValue, minValue) {
        const coordinates = this.calculatePointerInitialCoordinates(height, poGaugeStartAngle);
        const pointerDegrees = this.pointerRotation(value, maxValue, minValue);
        this.pointerCoordinates = { ...coordinates, pointerDegrees };
    }
    pointerRotation(value, maxValue, minValue) {
        const percent = this.convertValueToPercentage(value, maxValue, minValue);
        // valores referentes às angulações mínimas e máximas do ponteiro.
        const minRotation = 0;
        const maxRotation = 180;
        return (percent * (maxRotation - minRotation)) / 100 + minRotation;
    }
    calculatePointerInitialCoordinates(height, startAngleRadian) {
        const radius = height - PoGaugePointerEnd - PoGaugeThickness / 2;
        // Valor que representa a escala do ponteiro para plotagem.
        const scale = 40;
        const pointerScaledWidth = radius / scale;
        const pointerScaledBorderRadius = radius / (scale * 2);
        const sinAlpha = Math.sin(startAngleRadian);
        const cosAlpha = Math.cos(startAngleRadian);
        const targetX = radius + cosAlpha * radius;
        const targetY = radius + sinAlpha * radius;
        const startX = radius;
        const startY = radius + pointerScaledWidth;
        const endX = radius;
        const endY = radius - pointerScaledWidth;
        const coordinates = [
            'M',
            startX,
            startY,
            'L',
            targetX,
            targetY + pointerScaledBorderRadius,
            'A',
            1,
            1,
            0,
            '0,1',
            targetX,
            targetY - pointerScaledBorderRadius,
            'L',
            endX,
            endY,
            'Z'
        ].join(' ');
        return { coordinates, radius };
    }
    calculateCoordinates(height, startAngleRadian, endAngleRadian) {
        // Subtrai altura pelo excedente ponteiro em relação ao gráfico, pela metade do valor da coroa circular.
        const radius = height - PoGaugePointerEnd - PoGaugeThickness / 2;
        const innerRadius = radius - PoGaugeThickness;
        const sinAlpha = Math.sin(startAngleRadian);
        const cosAlpha = Math.cos(startAngleRadian);
        const sinBeta = Math.sin(endAngleRadian);
        const cosBeta = Math.cos(endAngleRadian);
        const startX = Math.round(radius + cosAlpha * radius);
        const startY = Math.round(radius + sinAlpha * radius);
        const endX = Math.round(radius + cosBeta * radius);
        const endY = Math.round(radius + sinBeta * radius);
        const startInnerX = Math.round(radius + cosAlpha * innerRadius);
        const startInnerY = Math.round(radius + sinAlpha * innerRadius);
        const endInnerX = Math.round(radius + cosBeta * innerRadius);
        const endInnerY = Math.round(radius + sinBeta * innerRadius);
        return [
            'M',
            startX,
            startY,
            'A',
            radius,
            radius,
            0,
            '0,1',
            endX,
            endY,
            'A',
            1,
            1,
            0,
            '0,1',
            endInnerX,
            endInnerY,
            'A',
            innerRadius,
            innerRadius,
            0,
            '0,0',
            startInnerX,
            startInnerY,
            'A',
            1,
            1,
            0,
            '0,1',
            startX,
            startY,
            'Z'
        ].join(' ');
    }
    calculateAngleRadius(value, maxValue, minValue = 0) {
        const angle = ((value - minValue) / (maxValue - minValue)) * (Math.PI * 2);
        return angle / 2;
    }
    convertValueToPercentage(value, maxValue, minValue) {
        return ((value - minValue) / (maxValue - minValue)) * 100;
    }
    setViewBox(height) {
        const width = this.calculateDiameter(height);
        this.viewBox = `0 ${-PoGaugePointerEnd} ${width} ${height}`;
    }
    calculateDiameter(height) {
        const radius = height - PoGaugePointerEnd - PoGaugeThickness / 2;
        return radius + Math.cos(0) * radius;
    }
    calculateMinAndMaxValues(ranges) {
        const minRange = this.getDomain(ranges, 'min');
        const maxRange = this.getDomain(ranges, 'max');
        return {
            minRange: this.verifyIfFloatOrInteger(minRange) ? minRange : 0,
            maxRange: this.verifyIfFloatOrInteger(maxRange) ? maxRange : 100
        };
    }
    verifyIfFloatOrInteger(number) {
        const notABoolean = typeof number !== 'boolean';
        const notInfinity = number !== Infinity;
        const isInteger = Number(number) === number && number % 1 === 0 && notInfinity;
        const isFloat = Number(number) === number && number % 1 !== 0 && notInfinity;
        return (notABoolean && isInteger) || (notABoolean && isFloat);
    }
    getDomain(ranges, type) {
        const rangeType = { min: 'from', max: 'to' };
        return Math[type](...ranges.map(range => range[rangeType[type]]));
    }
}
PoGaugeSvgComponent.ɵfac = function PoGaugeSvgComponent_Factory(t) { return new (t || PoGaugeSvgComponent)(); };
PoGaugeSvgComponent.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: PoGaugeSvgComponent, selectors: [["po-gauge-svg"]], inputs: { container: ["p-container", "container"], ranges: ["p-ranges", "ranges"], value: ["p-value", "value"] }, features: [i0.ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [["class", "po-gauge-svg", "preserveAspectRatio", "xMidYMax meet", "width", "100%", 4, "ngIf"], ["preserveAspectRatio", "xMidYMax meet", "width", "100%", 1, "po-gauge-svg"], ["po-gauge-path", "", 3, "p-base-coordinates", "p-ranges-coordinates"], ["po-gauge-pointer", "", 3, "p-coordinates", 4, "ngIf"], ["po-gauge-pointer", "", 3, "p-coordinates"]], template: function PoGaugeSvgComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵtemplate(0, PoGaugeSvgComponent__svg_svg_0_Template, 3, 5, "svg", 0);
    } if (rf & 2) {
        i0.ɵɵproperty("ngIf", ctx.addSvgElement);
    } }, dependencies: [i1.NgIf, i2.PoGaugePathComponent, i3.PoGaugePointerComponent], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PoGaugeSvgComponent, [{
        type: Component,
        args: [{ selector: 'po-gauge-svg', template: "<svg:svg\n  *ngIf=\"addSvgElement\"\n  class=\"po-gauge-svg\"\n  preserveAspectRatio=\"xMidYMax meet\"\n  width=\"100%\"\n  [attr.viewBox]=\"viewBox\"\n  [attr.height]=\"container?.height\"\n>\n  <!-- GAUGE PATHS -->\n  <svg:g po-gauge-path [p-base-coordinates]=\"baseCoordinates\" [p-ranges-coordinates]=\"coordinates\"></svg:g>\n\n  <!-- GAUGE POINTER -->\n  <svg:g *ngIf=\"hasRanges\" po-gauge-pointer [p-coordinates]=\"pointerCoordinates\"></svg:g>\n</svg:svg>\n" }]
    }], null, { container: [{
            type: Input,
            args: ['p-container']
        }], ranges: [{
            type: Input,
            args: ['p-ranges']
        }], value: [{
            type: Input,
            args: ['p-value']
        }] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZ2F1Z2Utc3ZnLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1nYXVnZS9wby1nYXVnZS1zdmcvcG8tZ2F1Z2Utc3ZnLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1nYXVnZS9wby1nYXVnZS1zdmcvcG8tZ2F1Z2Utc3ZnLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUE0QixNQUFNLGVBQWUsQ0FBQztBQUUzRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUVwSCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sK0NBQStDLENBQUM7Ozs7Ozs7SUNROUUsdUJBQXVGOzs7SUFBN0MseURBQW9DOzs7SUFaaEYsbUJBT0M7SUFQRCw4QkFPQztJQUVDLHVCQUF5RztJQUd6RyxnRkFBdUY7SUFDekYsaUJBQVU7OztJQVJSLHlDQUF3QixxRUFBQTtJQUlILGVBQXNDO0lBQXRDLDJEQUFzQyw0Q0FBQTtJQUduRCxlQUFlO0lBQWYsdUNBQWU7O0FERnpCLE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztBQU0xQyxNQUFNLE9BQU8sbUJBQW1CO0lBSmhDO1FBV0Usa0JBQWEsR0FBWSxLQUFLLENBQUM7S0FrUGhDO0lBNU9DLElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksT0FBTyxDQUFD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QUksV0FBVyxDQUFDO1FBQy9FLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxNQUFNLElBQUksTUFBTSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksV0FBVyxDQUFDO1FBRTdFLE9BQU8sQ0FBQyxXQUFXLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVPLFNBQVMsQ0FBQyxNQUE0QixFQUFFLElBQVk7UUFDMUQsTUFBTSxTQUFTLEdBQUcsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUU3QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7O3NGQXhQVSxtQkFBbUI7c0VBQW5CLG1CQUFtQjtRQ2hCaEMseUVBYVU7O1FBWlAsd0NBQW1COzt1RkRlVCxtQkFBbUI7Y0FKL0IsU0FBUzsyQkFDRSxjQUFjO2dCQUlGLFNBQVM7a0JBQTlCLEtBQUs7bUJBQUMsYUFBYTtZQUVELE1BQU07a0JBQXhCLEtBQUs7bUJBQUMsVUFBVTtZQUVDLEtBQUs7a0JBQXRCLEtBQUs7bUJBQUMsU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQb0dhdWdlUG9pbnRlckVuZCwgUG9HYXVnZVRoaWNrbmVzcywgcG9HYXVnZVRvdGFsVmFsdWVEZWZhdWx0IH0gZnJvbSAnLi4vcG8tZ2F1Z2UtZGVmYXVsdC12YWx1ZXMuY29uc3RhbnQnO1xuXG5pbXBvcnQgeyBQb0RlZmF1bHRDb2xvcnMgfSBmcm9tICcuLi8uLi8uLi9zZXJ2aWNlcy9wby1jb2xvci9wby1jb2xvcnMuY29uc3RhbnQnO1xuXG5pbXBvcnQgeyBQb0dhdWdlQ29vcmRpbmF0ZXMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL3BvLWdhdWdlLWNvb3JkaW5hdGVzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQb0dhdWdlUmFuZ2VzIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9wby1nYXVnZS1yYW5nZXMuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBvR2F1Z2VTdmdDb250YWluZXIgfSBmcm9tICcuLi9pbnRlcmZhY2VzL3BvLWdhdWdlLXN2Zy1jb250YWluZXIuaW50ZXJmYWNlJztcblxuZXhwb3J0IGNvbnN0IHBvR2F1Z2VTdGFydEFuZ2xlID0gLU1hdGguUEk7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3BvLWdhdWdlLXN2ZycsXG4gIHRlbXBsYXRlVXJsOiAnLi9wby1nYXVnZS1zdmcuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIFBvR2F1Z2VTdmdDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoJ3AtY29udGFpbmVyJykgY29udGFpbmVyOiBQb0dhdWdlU3ZnQ29udGFpbmVyO1xuXG4gIEBJbnB1dCgncC1yYW5nZXMnKSByYW5nZXM6IEFycmF5PFBvR2F1Z2VSYW5nZXM+O1xuXG4gIEBJbnB1dCgncC12YWx1ZScpIHZhbHVlOiBudW1iZXI7XG5cbiAgYWRkU3ZnRWxlbWVudDogYm9vbGVhbiA9IGZhbHNlO1xuICBiYXNlQ29vcmRpbmF0ZXM6IFBvR2F1Z2VDb29yZGluYXRlcztcbiAgY29vcmRpbmF0ZXM6IEFycmF5PFBvR2F1Z2VDb29yZGluYXRlcz47XG4gIHBvaW50ZXJDb29yZGluYXRlczogUG9HYXVnZUNvb3JkaW5hdGVzO1xuICB2aWV3Qm94OiBzdHJpbmc7XG5cbiAgZ2V0IGhhc1JhbmdlcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoKHRoaXMuY29udGFpbmVyICYmIGNoYW5nZXMudmFsdWUpIHx8ICh0aGlzLmNvbnRhaW5lciAmJiBjaGFuZ2VzLnJhbmdlcykgfHwgdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXModGhpcy52YWx1ZSwgdGhpcy5yYW5nZXMsIHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldENvb3JkaW5hdGVzKHZhbHVlOiBudW1iZXIsIHJhbmdlczogQXJyYXk8UG9HYXVnZVJhbmdlcz4sIGNvbnRhaW5lcjogUG9HYXVnZVN2Z0NvbnRhaW5lcik6IHZvaWQge1xuICAgIGNvbnN0IHsgaGVpZ2h0IH0gPSBjb250YWluZXI7XG5cbiAgICAvLyBBZGljaW9uYSBlbGVtZW50byBzdmcgc29tZW50ZSBhcMOzcyBjYWxjdWxhciBhIGFsdHVyYSBkbyBjb250YWluZXIgcG9pcyBvIHN2ZyB0ZW0gYWx0dXJhIGRlZmF1bHQgZGUgMTUwcHguXG4gICAgdGhpcy5hZGRTdmdFbGVtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLnNldFZpZXdCb3goaGVpZ2h0KTtcbiAgICB0aGlzLnNldEJhc2VDb29yZGluYXRlcyhoZWlnaHQpO1xuXG4gICAgaWYgKCFyYW5nZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnNldFNpbmdsZVJhbmdlQ29vcmRpbmF0ZXMoaGVpZ2h0LCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0UmFuZ2VzQ29vcmRpbmF0ZXMoaGVpZ2h0LCB2YWx1ZSwgcmFuZ2VzKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0QmFzZUNvb3JkaW5hdGVzKGhlaWdodDogUG9HYXVnZVN2Z0NvbnRhaW5lclsnaGVpZ2h0J10pOiB2b2lkIHtcbiAgICBjb25zdCBlbmRBbmdsZVJhZGlhbiA9IDA7XG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmNhbGN1bGF0ZUNvb3JkaW5hdGVzKGhlaWdodCwgcG9HYXVnZVN0YXJ0QW5nbGUsIGVuZEFuZ2xlUmFkaWFuKTtcblxuICAgIHRoaXMuYmFzZUNvb3JkaW5hdGVzID0geyBjb29yZGluYXRlcyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRSYW5nZXNDb29yZGluYXRlcyhoZWlnaHQ6IG51bWJlciwgdmFsdWU6IG51bWJlciA9IDAsIHJhbmdlczogQXJyYXk8UG9HYXVnZVJhbmdlcz4pOiB2b2lkIHtcbiAgICBjb25zdCB7IG1pblJhbmdlLCBtYXhSYW5nZSB9ID0gdGhpcy5jYWxjdWxhdGVNaW5BbmRNYXhWYWx1ZXMocmFuZ2VzKTtcblxuICAgIGNvbnN0IG1pblZhbHVlID0gdmFsdWUgPCBtaW5SYW5nZSA/IHZhbHVlIDogbWluUmFuZ2U7XG4gICAgY29uc3QgbWF4VmFsdWUgPSB2YWx1ZSA+IG1heFJhbmdlID8gdmFsdWUgOiBtYXhSYW5nZTtcblxuICAgIHRoaXMuc2V0UG9pbnRlckNvb3JkaW5hdGVzKGhlaWdodCwgdmFsdWUsIG1heFZhbHVlLCBtaW5WYWx1ZSk7XG5cbiAgICAvLyBgLnJldmVyc2UoKWAgbm8gdMOpcm1pbm8gZGEgaXRlcmHDp8OjbyBwYXJhIHRyYXRhciBhIHNvYnJlcG9zaWPDo28gY29ycmV0YSBkYXMgYm9yZGFzIGFycmVkb25kYWRhcyBkb3MgcmFuZ2VzLlxuICAgIGNvbnN0IHJhbmdlc0Nvb3JkaW5hdGVzID0gcmFuZ2VzXG4gICAgICAubWFwKChyYW5nZTogUG9HYXVnZVJhbmdlcykgPT4ge1xuICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuZnJvbSA/PyAwO1xuICAgICAgICBjb25zdCB0byA9IHJhbmdlLnRvID8/IG1heFJhbmdlO1xuICAgICAgICBjb25zdCBzdGFydEFuZ2xlUmFkaWFuID0gcG9HYXVnZVN0YXJ0QW5nbGUgKyB0aGlzLmNhbGN1bGF0ZUFuZ2xlUmFkaXVzKGZyb20sIG1heFZhbHVlLCBtaW5WYWx1ZSk7XG4gICAgICAgIGNvbnN0IGVuZEFuZ2xlUmFkaWFuID0gcG9HYXVnZVN0YXJ0QW5nbGUgKyB0aGlzLmNhbGN1bGF0ZUFuZ2xlUmFkaXVzKHRvLCBtYXhWYWx1ZSwgbWluVmFsdWUpO1xuXG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gdGhpcy5jYWxjdWxhdGVDb29yZGluYXRlcyhoZWlnaHQsIHN0YXJ0QW5nbGVSYWRpYW4sIGVuZEFuZ2xlUmFkaWFuKTtcblxuICAgICAgICByZXR1cm4geyBjb29yZGluYXRlcywgY29sb3I6IHJhbmdlLmNvbG9yIH07XG4gICAgICB9KVxuICAgICAgLnJldmVyc2UoKTtcblxuICAgIHRoaXMuY29vcmRpbmF0ZXMgPSByYW5nZXNDb29yZGluYXRlcztcbiAgfVxuXG4gIHByaXZhdGUgc2V0U2luZ2xlUmFuZ2VDb29yZGluYXRlcyhoZWlnaHQ6IFBvR2F1Z2VTdmdDb250YWluZXJbJ2hlaWdodCddLCB2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgdmVyaWZpZWRWYWx1ZSA9IHZhbHVlID4gMTAwID8gMTAwIDogdmFsdWU7XG5cbiAgICBjb25zdCBlbmRBbmdsZVJhZGlhbiA9IHBvR2F1Z2VTdGFydEFuZ2xlICsgdGhpcy5jYWxjdWxhdGVBbmdsZVJhZGl1cyh2ZXJpZmllZFZhbHVlLCBwb0dhdWdlVG90YWxWYWx1ZURlZmF1bHQpO1xuXG4gICAgY29uc3QgY29vcmRpbmF0ZXMgPSB2YWx1ZSA+IDAgPyB0aGlzLmNhbGN1bGF0ZUNvb3JkaW5hdGVzKGhlaWdodCwgcG9HYXVnZVN0YXJ0QW5nbGUsIGVuZEFuZ2xlUmFkaWFuKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjb2xvciA9IFBvRGVmYXVsdENvbG9yc1swXVswXTtcbiAgICB0aGlzLmNvb3JkaW5hdGVzID0gW3sgY29vcmRpbmF0ZXMsIGNvbG9yIH1dO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRQb2ludGVyQ29vcmRpbmF0ZXMoaGVpZ2h0OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIG1heFZhbHVlOiBudW1iZXIsIG1pblZhbHVlOiBudW1iZXIpIHtcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHRoaXMuY2FsY3VsYXRlUG9pbnRlckluaXRpYWxDb29yZGluYXRlcyhoZWlnaHQsIHBvR2F1Z2VTdGFydEFuZ2xlKTtcbiAgICBjb25zdCBwb2ludGVyRGVncmVlcyA9IHRoaXMucG9pbnRlclJvdGF0aW9uKHZhbHVlLCBtYXhWYWx1ZSwgbWluVmFsdWUpO1xuXG4gICAgdGhpcy5wb2ludGVyQ29vcmRpbmF0ZXMgPSB7IC4uLmNvb3JkaW5hdGVzLCBwb2ludGVyRGVncmVlcyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBwb2ludGVyUm90YXRpb24odmFsdWU6IG51bWJlciwgbWF4VmFsdWU6IG51bWJlciwgbWluVmFsdWU6IG51bWJlcikge1xuICAgIGNvbnN0IHBlcmNlbnQgPSB0aGlzLmNvbnZlcnRWYWx1ZVRvUGVyY2VudGFnZSh2YWx1ZSwgbWF4VmFsdWUsIG1pblZhbHVlKTtcbiAgICAvLyB2YWxvcmVzIHJlZmVyZW50ZXMgw6BzIGFuZ3VsYcOnw7VlcyBtw61uaW1hcyBlIG3DoXhpbWFzIGRvIHBvbnRlaXJvLlxuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IDE4MDtcblxuICAgIHJldHVybiAocGVyY2VudCAqIChtYXhSb3RhdGlvbiAtIG1pblJvdGF0aW9uKSkgLyAxMDAgKyBtaW5Sb3RhdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlUG9pbnRlckluaXRpYWxDb29yZGluYXRlcyhoZWlnaHQ6IG51bWJlciwgc3RhcnRBbmdsZVJhZGlhbjogbnVtYmVyKSB7XG4gICAgY29uc3QgcmFkaXVzID0gaGVpZ2h0IC0gUG9HYXVnZVBvaW50ZXJFbmQgLSBQb0dhdWdlVGhpY2tuZXNzIC8gMjtcblxuICAgIC8vIFZhbG9yIHF1ZSByZXByZXNlbnRhIGEgZXNjYWxhIGRvIHBvbnRlaXJvIHBhcmEgcGxvdGFnZW0uXG4gICAgY29uc3Qgc2NhbGUgPSA0MDtcbiAgICBjb25zdCBwb2ludGVyU2NhbGVkV2lkdGggPSByYWRpdXMgLyBzY2FsZTtcbiAgICBjb25zdCBwb2ludGVyU2NhbGVkQm9yZGVyUmFkaXVzID0gcmFkaXVzIC8gKHNjYWxlICogMik7XG5cbiAgICBjb25zdCBzaW5BbHBoYSA9IE1hdGguc2luKHN0YXJ0QW5nbGVSYWRpYW4pO1xuICAgIGNvbnN0IGNvc0FscGhhID0gTWF0aC5jb3Moc3RhcnRBbmdsZVJhZGlhbik7XG5cbiAgICBjb25zdCB0YXJnZXRYID0gcmFkaXVzICsgY29zQWxwaGEgKiByYWRpdXM7XG4gICAgY29uc3QgdGFyZ2V0WSA9IHJhZGl1cyArIHNpbkFscGhhICogcmFkaXVzO1xuXG4gICAgY29uc3Qgc3RhcnRYID0gcmFkaXVzO1xuICAgIGNvbnN0IHN0YXJ0WSA9IHJhZGl1cyArIHBvaW50ZXJTY2FsZWRXaWR0aDtcblxuICAgIGNvbnN0IGVuZFggPSByYWRpdXM7XG4gICAgY29uc3QgZW5kWSA9IHJhZGl1cyAtIHBvaW50ZXJTY2FsZWRXaWR0aDtcblxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gW1xuICAgICAgJ00nLFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgJ0wnLFxuICAgICAgdGFyZ2V0WCxcbiAgICAgIHRhcmdldFkgKyBwb2ludGVyU2NhbGVkQm9yZGVyUmFkaXVzLFxuICAgICAgJ0EnLFxuICAgICAgMSxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgJzAsMScsXG4gICAgICB0YXJnZXRYLFxuICAgICAgdGFyZ2V0WSAtIHBvaW50ZXJTY2FsZWRCb3JkZXJSYWRpdXMsXG4gICAgICAnTCcsXG4gICAgICBlbmRYLFxuICAgICAgZW5kWSxcbiAgICAgICdaJ1xuICAgIF0uam9pbignICcpO1xuXG4gICAgcmV0dXJuIHsgY29vcmRpbmF0ZXMsIHJhZGl1cyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVDb29yZGluYXRlcyhcbiAgICBoZWlnaHQ6IFBvR2F1Z2VTdmdDb250YWluZXJbJ2hlaWdodCddLFxuICAgIHN0YXJ0QW5nbGVSYWRpYW46IG51bWJlcixcbiAgICBlbmRBbmdsZVJhZGlhbjogbnVtYmVyXG4gICk6IFBvR2F1Z2VDb29yZGluYXRlc1snY29vcmRpbmF0ZXMnXSB7XG4gICAgLy8gU3VidHJhaSBhbHR1cmEgcGVsbyBleGNlZGVudGUgcG9udGVpcm8gZW0gcmVsYcOnw6NvIGFvIGdyw6FmaWNvLCBwZWxhIG1ldGFkZSBkbyB2YWxvciBkYSBjb3JvYSBjaXJjdWxhci5cbiAgICBjb25zdCByYWRpdXMgPSBoZWlnaHQgLSBQb0dhdWdlUG9pbnRlckVuZCAtIFBvR2F1Z2VUaGlja25lc3MgLyAyO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gcmFkaXVzIC0gUG9HYXVnZVRoaWNrbmVzcztcblxuICAgIGNvbnN0IHNpbkFscGhhID0gTWF0aC5zaW4oc3RhcnRBbmdsZVJhZGlhbik7XG4gICAgY29uc3QgY29zQWxwaGEgPSBNYXRoLmNvcyhzdGFydEFuZ2xlUmFkaWFuKTtcblxuICAgIGNvbnN0IHNpbkJldGEgPSBNYXRoLnNpbihlbmRBbmdsZVJhZGlhbik7XG4gICAgY29uc3QgY29zQmV0YSA9IE1hdGguY29zKGVuZEFuZ2xlUmFkaWFuKTtcblxuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGgucm91bmQocmFkaXVzICsgY29zQWxwaGEgKiByYWRpdXMpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGgucm91bmQocmFkaXVzICsgc2luQWxwaGEgKiByYWRpdXMpO1xuXG4gICAgY29uc3QgZW5kWCA9IE1hdGgucm91bmQocmFkaXVzICsgY29zQmV0YSAqIHJhZGl1cyk7XG4gICAgY29uc3QgZW5kWSA9IE1hdGgucm91bmQocmFkaXVzICsgc2luQmV0YSAqIHJhZGl1cyk7XG5cbiAgICBjb25zdCBzdGFydElubmVyWCA9IE1hdGgucm91bmQocmFkaXVzICsgY29zQWxwaGEgKiBpbm5lclJhZGl1cyk7XG4gICAgY29uc3Qgc3RhcnRJbm5lclkgPSBNYXRoLnJvdW5kKHJhZGl1cyArIHNpbkFscGhhICogaW5uZXJSYWRpdXMpO1xuXG4gICAgY29uc3QgZW5kSW5uZXJYID0gTWF0aC5yb3VuZChyYWRpdXMgKyBjb3NCZXRhICogaW5uZXJSYWRpdXMpO1xuICAgIGNvbnN0IGVuZElubmVyWSA9IE1hdGgucm91bmQocmFkaXVzICsgc2luQmV0YSAqIGlubmVyUmFkaXVzKTtcblxuICAgIHJldHVybiBbXG4gICAgICAnTScsXG4gICAgICBzdGFydFgsXG4gICAgICBzdGFydFksXG4gICAgICAnQScsXG4gICAgICByYWRpdXMsXG4gICAgICByYWRpdXMsXG4gICAgICAwLFxuICAgICAgJzAsMScsXG4gICAgICBlbmRYLFxuICAgICAgZW5kWSxcbiAgICAgICdBJyxcbiAgICAgIDEsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgICcwLDEnLFxuICAgICAgZW5kSW5uZXJYLFxuICAgICAgZW5kSW5uZXJZLFxuICAgICAgJ0EnLFxuICAgICAgaW5uZXJSYWRpdXMsXG4gICAgICBpbm5lclJhZGl1cyxcbiAgICAgIDAsXG4gICAgICAnMCwwJyxcbiAgICAgIHN0YXJ0SW5uZXJYLFxuICAgICAgc3RhcnRJbm5lclksXG4gICAgICAnQScsXG4gICAgICAxLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAnMCwxJyxcbiAgICAgIHN0YXJ0WCxcbiAgICAgIHN0YXJ0WSxcbiAgICAgICdaJ1xuICAgIF0uam9pbignICcpO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVBbmdsZVJhZGl1cyh2YWx1ZTogbnVtYmVyLCBtYXhWYWx1ZTogbnVtYmVyLCBtaW5WYWx1ZTogbnVtYmVyID0gMCk6IG51bWJlciB7XG4gICAgY29uc3QgYW5nbGUgPSAoKHZhbHVlIC0gbWluVmFsdWUpIC8gKG1heFZhbHVlIC0gbWluVmFsdWUpKSAqIChNYXRoLlBJICogMik7XG5cbiAgICByZXR1cm4gYW5nbGUgLyAyO1xuICB9XG5cbiAgcHJpdmF0ZSBjb252ZXJ0VmFsdWVUb1BlcmNlbnRhZ2UodmFsdWU6IG51bWJlciwgbWF4VmFsdWU6IG51bWJlciwgbWluVmFsdWUpOiBudW1iZXIge1xuICAgIHJldHVybiAoKHZhbHVlIC0gbWluVmFsdWUpIC8gKG1heFZhbHVlIC0gbWluVmFsdWUpKSAqIDEwMDtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Vmlld0JveChoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jYWxjdWxhdGVEaWFtZXRlcihoZWlnaHQpO1xuXG4gICAgdGhpcy52aWV3Qm94ID0gYDAgJHstUG9HYXVnZVBvaW50ZXJFbmR9ICR7d2lkdGh9ICR7aGVpZ2h0fWA7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZURpYW1ldGVyKGhlaWdodDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCByYWRpdXMgPSBoZWlnaHQgLSBQb0dhdWdlUG9pbnRlckVuZCAtIFBvR2F1Z2VUaGlja25lc3MgLyAyO1xuXG4gICAgcmV0dXJuIHJhZGl1cyArIE1hdGguY29zKDApICogcmFkaXVzO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVNaW5BbmRNYXhWYWx1ZXMocmFuZ2VzOiBBcnJheTxQb0dhdWdlUmFuZ2VzPikge1xuICAgIGNvbnN0IG1pblJhbmdlID0gdGhpcy5nZXREb21haW4ocmFuZ2VzLCAnbWluJyk7XG4gICAgY29uc3QgbWF4UmFuZ2UgPSB0aGlzLmdldERvbWFpbihyYW5nZXMsICdtYXgnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW5SYW5nZTogdGhpcy52ZXJpZnlJZkZsb2F0T3JJbnRlZ2VyKG1pblJhbmdlKSA/IG1pblJhbmdlIDogMCxcbiAgICAgIG1heFJhbmdlOiB0aGlzLnZlcmlmeUlmRmxvYXRPckludGVnZXIobWF4UmFuZ2UpID8gbWF4UmFuZ2UgOiAxMDBcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB2ZXJpZnlJZkZsb2F0T3JJbnRlZ2VyKG51bWJlcjogbnVtYmVyKSB7XG4gICAgY29uc3Qgbm90QUJvb2xlYW4gPSB0eXBlb2YgbnVtYmVyICE9PSAnYm9vbGVhbic7XG4gICAgY29uc3Qgbm90SW5maW5pdHkgPSBudW1iZXIgIT09IEluZmluaXR5O1xuXG4gICAgY29uc3QgaXNJbnRlZ2VyID0gTnVtYmVyKG51bWJlcikgPT09IG51bWJlciAmJiBudW1iZXIgJSAxID09PSAwICYmIG5vdEluZmluaXR5O1xuICAgIGNvbnN0IGlzRmxvYXQgPSBOdW1iZXIobnVtYmVyKSA9PT0gbnVtYmVyICYmIG51bWJlciAlIDEgIT09IDAgJiYgbm90SW5maW5pdHk7XG5cbiAgICByZXR1cm4gKG5vdEFCb29sZWFuICYmIGlzSW50ZWdlcikgfHwgKG5vdEFCb29sZWFuICYmIGlzRmxvYXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREb21haW4ocmFuZ2VzOiBBcnJheTxQb0dhdWdlUmFuZ2VzPiwgdHlwZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCByYW5nZVR5cGUgPSB7IG1pbjogJ2Zyb20nLCBtYXg6ICd0bycgfTtcblxuICAgIHJldHVybiBNYXRoW3R5cGVdKC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2VbcmFuZ2VUeXBlW3R5cGVdXSkpO1xuICB9XG59XG4iLCI8c3ZnOnN2Z1xuICAqbmdJZj1cImFkZFN2Z0VsZW1lbnRcIlxuICBjbGFzcz1cInBvLWdhdWdlLXN2Z1wiXG4gIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWlkWU1heCBtZWV0XCJcbiAgd2lkdGg9XCIxMDAlXCJcbiAgW2F0dHIudmlld0JveF09XCJ2aWV3Qm94XCJcbiAgW2F0dHIuaGVpZ2h0XT1cImNvbnRhaW5lcj8uaGVpZ2h0XCJcbj5cbiAgPCEtLSBHQVVHRSBQQVRIUyAtLT5cbiAgPHN2ZzpnIHBvLWdhdWdlLXBhdGggW3AtYmFzZS1jb29yZGluYXRlc109XCJiYXNlQ29vcmRpbmF0ZXNcIiBbcC1yYW5nZXMtY29vcmRpbmF0ZXNdPVwiY29vcmRpbmF0ZXNcIj48L3N2ZzpnPlxuXG4gIDwhLS0gR0FVR0UgUE9JTlRFUiAtLT5cbiAgPHN2ZzpnICpuZ0lmPVwiaGFzUmFuZ2VzXCIgcG8tZ2F1Z2UtcG9pbnRlciBbcC1jb29yZGluYXRlc109XCJwb2ludGVyQ29vcmRpbmF0ZXNcIj48L3N2ZzpnPlxuPC9zdmc6c3ZnPlxuIl19