import { Input, Directive } from '@angular/core';
import { convertToInt } from '../../utils/util';
import { poGaugeMinHeight } from './po-gauge-default-values.constant';
import * as i0 from "@angular/core";
import * as i1 from "../../services/po-color/po-color.service";
/**
 * @description
 *
 * O componente `po-gauge` provê a representação de um valor através de um arco. É muito comum, por exemplo, para demonstrar o desempenho ou progresso de algo.
 * O `po-gauge` possui dois tipos de tratamentos:
 * - É possível demonstrar um dado percentual simples em conjunto com uma descrição resumida em seu interior;
 * - Para um demonstrativo mais elaborado, consegue-se definir alcances em cores, um breve texto descritivo e um ponteiro indicando o valor desejado.
 *
 * #### Guia de uso para Gráficos
 *
 * > Veja nosso [guia de uso para gráficos](/guides/guide-charts) para auxiliar na construção do seu gráfico,
 * informando em qual caso utilizar, o que devemos evitar e boas práticas relacionada a cores.
 */
export class PoGaugeBaseComponent {
    constructor(colorService) {
        this.colorService = colorService;
        this._height = poGaugeMinHeight;
        this._ranges = [];
    }
    /**
     * @optional
     *
     * @description
     *
     * Define o texto que será exibido no gauge.
     * Há dois posicionamentos para ele:
     * - Se houver definição para `p-ranges`, o descritivo será exibido no topo do container, ficando acima do gauge;
     * - Na ausência de `p-ranges`, será incorporado dentro do arco do gauge, e abaixo de `p-value`.
     *
     * Para ambos os casos, se o conteúdo ultrapassar a área designada, serão geradas automaticamente reticências.
     * No entanto, será possível visualizar a mensagem através de um tooltip no passar do mouse sobre o texto.
     *
     * > Para uma melhor experiência do usuário, é recomendado um descritivo breve e com poucas palavras.
     * Desta forma evita-se o *overflow* do texto.
     */
    set description(value) {
        this._description = value;
        this.svgContainerSize();
    }
    get description() {
        return this._description;
    }
    /**
     * @optional
     *
     * @description
     *
     * Define a altura do gauge.
     *
     * O valor mínimo aceito é 300px.
     *
     * @default `300px`
     */
    set height(value) {
        this._height = this.setGaugeHeight(value);
        this.svgContainerSize();
    }
    get height() {
        return this._height;
    }
    /**
     * @optional
     *
     * @description
     *
     * Definição para o alcance de cores. Ao adicionar pelo menos um item na lista,
     * incorpora-se o ponteiro que assinala o valor passado em `p-value`.
     * Se o valor de `p-value` for inferior ao mínimo valor definido em `PoGaugeRanges.from`, o domínio mínimo do gauge será `p-value`.
     * A mesma regra prevalece para valores máximos.
     */
    set ranges(value) {
        this._ranges = Array.isArray(value) ? this.verifyColors(value) : [];
        this.svgContainerSize();
    }
    get ranges() {
        return this._ranges;
    }
    /**
     * @optional
     *
     * @description
     *
     * Define o título do gauge.
     */
    set title(value) {
        this._title = value;
        this.svgContainerSize();
    }
    get title() {
        return this._title;
    }
    /**
     * @optional
     *
     * @description
     *
     * Valor referente ao valor da série. Seu comportamento segue a seguintes regras:
     *
     * - Sem `p-ranges`: Os valores passados para `p-value` e `p-description` serão centralizados no interior do arco.
     * A base do valor será percentual tendo como base os alcances entre zero e 100%. Se passado um valor superior a 100,
     * A colorização do gauge será completa e o valor passado será exibido no interior do arco.
     * - Com `p-ranges`: A descrição será exibida acima do gauge e haverá um ponteiro marcando o valor passado em `p-value`.
     * Considerando que o alcance em `ranges` é aberto, então a escala de `p-value` será em relação ao menor/maior alcance
     * absoluto definido em `p-ranges`.
     * Se passado um `p-value` inferior em relação ao mínimo valor definido em `p-ranges`, o domínio mínimo do gauge partirá de `p-value`.
     * A mesma regra prevalece para valores máximos.
     *
     */
    set value(gaugeValue) {
        if (typeof gaugeValue === 'number' || (typeof gaugeValue === 'string' && gaugeValue.trim())) {
            const value = !isNaN(gaugeValue) ? Number(gaugeValue) : undefined;
            this._value = value;
        }
        else {
            this._value = undefined;
        }
    }
    get value() {
        return this._value;
    }
    verifyColors(ranges) {
        return this.colorService.getColors(ranges);
    }
    setGaugeHeight(height) {
        const gaugeHeight = convertToInt(height);
        return gaugeHeight && gaugeHeight > poGaugeMinHeight ? gaugeHeight : poGaugeMinHeight;
    }
}
PoGaugeBaseComponent.ɵfac = function PoGaugeBaseComponent_Factory(t) { return new (t || PoGaugeBaseComponent)(i0.ɵɵdirectiveInject(i1.PoColorService)); };
PoGaugeBaseComponent.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: PoGaugeBaseComponent, inputs: { description: ["p-description", "description"], height: ["p-height", "height"], ranges: ["p-ranges", "ranges"], title: ["p-title", "title"], value: ["p-value", "value"] } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PoGaugeBaseComponent, [{
        type: Directive
    }], function () { return [{ type: i1.PoColorService }]; }, { description: [{
            type: Input,
            args: ['p-description']
        }], height: [{
            type: Input,
            args: ['p-height']
        }], ranges: [{
            type: Input,
            args: ['p-ranges']
        }], title: [{
            type: Input,
            args: ['p-title']
        }], value: [{
            type: Input,
            args: ['p-value']
        }] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZ2F1Z2UtYmFzZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy91aS9zcmMvbGliL2NvbXBvbmVudHMvcG8tZ2F1Z2UvcG8tZ2F1Z2UtYmFzZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFakQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG9DQUFvQyxDQUFDOzs7QUFNdEU7Ozs7Ozs7Ozs7OztHQVlHO0FBRUgsTUFBTSxPQUFnQixvQkFBb0I7SUF3SHhDLFlBQXNCLFlBQTRCO1FBQTVCLGlCQUFZLEdBQVosWUFBWSxDQUFnQjtRQXRIMUMsWUFBTyxHQUFXLGdCQUFnQixDQUFDO1FBQ25DLFlBQU8sR0FBeUIsRUFBRSxDQUFDO0lBcUhVLENBQUM7SUFqSHREOzs7Ozs7Ozs7Ozs7Ozs7T0FlRztJQUNILElBQTRCLFdBQVcsQ0FBQyxLQUFhO1FBQ25ELElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBRTFCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRCxJQUFJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxJQUF1QixNQUFNLENBQUMsS0FBYTtRQUN6QyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVELElBQUksTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsSUFBdUIsTUFBTSxDQUFDLEtBQTJCO1FBQ3ZELElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3BFLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRCxJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILElBQXNCLEtBQUssQ0FBQyxLQUFhO1FBQ3ZDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBRXBCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRCxJQUFJLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BZ0JHO0lBQ0gsSUFBc0IsS0FBSyxDQUFDLFVBQWtCO1FBQzVDLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxJQUFJLENBQUMsT0FBTyxVQUFVLEtBQUssUUFBUSxJQUFhLFVBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFO1lBQ3JHLE1BQU0sS0FBSyxHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUVsRSxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztTQUNyQjthQUFNO1lBQ0wsSUFBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7U0FDekI7SUFDSCxDQUFDO0lBRUQsSUFBSSxLQUFLO1FBQ1AsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3JCLENBQUM7SUFJTyxZQUFZLENBQUMsTUFBNEI7UUFDL0MsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBZ0IsTUFBTSxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVPLGNBQWMsQ0FBQyxNQUFjO1FBQ25DLE1BQU0sV0FBVyxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV6QyxPQUFPLFdBQVcsSUFBSSxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7SUFDeEYsQ0FBQzs7d0ZBbEltQixvQkFBb0I7dUVBQXBCLG9CQUFvQjt1RkFBcEIsb0JBQW9CO2NBRHpDLFNBQVM7aUVBd0JvQixXQUFXO2tCQUF0QyxLQUFLO21CQUFDLGVBQWU7WUFxQkMsTUFBTTtrQkFBNUIsS0FBSzttQkFBQyxVQUFVO1lBbUJNLE1BQU07a0JBQTVCLEtBQUs7bUJBQUMsVUFBVTtZQWdCSyxLQUFLO2tCQUExQixLQUFLO21CQUFDLFNBQVM7WUEyQk0sS0FBSztrQkFBMUIsS0FBSzttQkFBQyxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5wdXQsIERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBjb252ZXJ0VG9JbnQgfSBmcm9tICcuLi8uLi91dGlscy91dGlsJztcbmltcG9ydCB7IHBvR2F1Z2VNaW5IZWlnaHQgfSBmcm9tICcuL3BvLWdhdWdlLWRlZmF1bHQtdmFsdWVzLmNvbnN0YW50JztcblxuaW1wb3J0IHsgUG9Db2xvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9wby1jb2xvci9wby1jb2xvci5zZXJ2aWNlJztcblxuaW1wb3J0IHsgUG9HYXVnZVJhbmdlcyB9IGZyb20gJy4vaW50ZXJmYWNlcy9wby1nYXVnZS1yYW5nZXMuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBPIGNvbXBvbmVudGUgYHBvLWdhdWdlYCBwcm92w6ogYSByZXByZXNlbnRhw6fDo28gZGUgdW0gdmFsb3IgYXRyYXbDqXMgZGUgdW0gYXJjby4gw4kgbXVpdG8gY29tdW0sIHBvciBleGVtcGxvLCBwYXJhIGRlbW9uc3RyYXIgbyBkZXNlbXBlbmhvIG91IHByb2dyZXNzbyBkZSBhbGdvLlxuICogTyBgcG8tZ2F1Z2VgIHBvc3N1aSBkb2lzIHRpcG9zIGRlIHRyYXRhbWVudG9zOlxuICogLSDDiSBwb3Nzw612ZWwgZGVtb25zdHJhciB1bSBkYWRvIHBlcmNlbnR1YWwgc2ltcGxlcyBlbSBjb25qdW50byBjb20gdW1hIGRlc2NyacOnw6NvIHJlc3VtaWRhIGVtIHNldSBpbnRlcmlvcjtcbiAqIC0gUGFyYSB1bSBkZW1vbnN0cmF0aXZvIG1haXMgZWxhYm9yYWRvLCBjb25zZWd1ZS1zZSBkZWZpbmlyIGFsY2FuY2VzIGVtIGNvcmVzLCB1bSBicmV2ZSB0ZXh0byBkZXNjcml0aXZvIGUgdW0gcG9udGVpcm8gaW5kaWNhbmRvIG8gdmFsb3IgZGVzZWphZG8uXG4gKlxuICogIyMjIyBHdWlhIGRlIHVzbyBwYXJhIEdyw6FmaWNvc1xuICpcbiAqID4gVmVqYSBub3NzbyBbZ3VpYSBkZSB1c28gcGFyYSBncsOhZmljb3NdKC9ndWlkZXMvZ3VpZGUtY2hhcnRzKSBwYXJhIGF1eGlsaWFyIG5hIGNvbnN0cnXDp8OjbyBkbyBzZXUgZ3LDoWZpY28sXG4gKiBpbmZvcm1hbmRvIGVtIHF1YWwgY2FzbyB1dGlsaXphciwgbyBxdWUgZGV2ZW1vcyBldml0YXIgZSBib2FzIHByw6F0aWNhcyByZWxhY2lvbmFkYSBhIGNvcmVzLlxuICovXG5ARGlyZWN0aXZlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb0dhdWdlQmFzZUNvbXBvbmVudCB7XG4gIHByaXZhdGUgX2Rlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHByaXZhdGUgX2hlaWdodDogbnVtYmVyID0gcG9HYXVnZU1pbkhlaWdodDtcbiAgcHJpdmF0ZSBfcmFuZ2VzOiBBcnJheTxQb0dhdWdlUmFuZ2VzPiA9IFtdO1xuICBwcml2YXRlIF90aXRsZTogc3RyaW5nO1xuICBwcml2YXRlIF92YWx1ZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBvIHRleHRvIHF1ZSBzZXLDoSBleGliaWRvIG5vIGdhdWdlLlxuICAgKiBIw6EgZG9pcyBwb3NpY2lvbmFtZW50b3MgcGFyYSBlbGU6XG4gICAqIC0gU2UgaG91dmVyIGRlZmluacOnw6NvIHBhcmEgYHAtcmFuZ2VzYCwgbyBkZXNjcml0aXZvIHNlcsOhIGV4aWJpZG8gbm8gdG9wbyBkbyBjb250YWluZXIsIGZpY2FuZG8gYWNpbWEgZG8gZ2F1Z2U7XG4gICAqIC0gTmEgYXVzw6puY2lhIGRlIGBwLXJhbmdlc2AsIHNlcsOhIGluY29ycG9yYWRvIGRlbnRybyBkbyBhcmNvIGRvIGdhdWdlLCBlIGFiYWl4byBkZSBgcC12YWx1ZWAuXG4gICAqXG4gICAqIFBhcmEgYW1ib3Mgb3MgY2Fzb3MsIHNlIG8gY29udGXDumRvIHVsdHJhcGFzc2FyIGEgw6FyZWEgZGVzaWduYWRhLCBzZXLDo28gZ2VyYWRhcyBhdXRvbWF0aWNhbWVudGUgcmV0aWPDqm5jaWFzLlxuICAgKiBObyBlbnRhbnRvLCBzZXLDoSBwb3Nzw612ZWwgdmlzdWFsaXphciBhIG1lbnNhZ2VtIGF0cmF2w6lzIGRlIHVtIHRvb2x0aXAgbm8gcGFzc2FyIGRvIG1vdXNlIHNvYnJlIG8gdGV4dG8uXG4gICAqXG4gICAqID4gUGFyYSB1bWEgbWVsaG9yIGV4cGVyacOqbmNpYSBkbyB1c3XDoXJpbywgw6kgcmVjb21lbmRhZG8gdW0gZGVzY3JpdGl2byBicmV2ZSBlIGNvbSBwb3VjYXMgcGFsYXZyYXMuXG4gICAqIERlc3RhIGZvcm1hIGV2aXRhLXNlIG8gKm92ZXJmbG93KiBkbyB0ZXh0by5cbiAgICovXG4gIEBJbnB1dCgncC1kZXNjcmlwdGlvbicpIHNldCBkZXNjcmlwdGlvbih2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fZGVzY3JpcHRpb24gPSB2YWx1ZTtcblxuICAgIHRoaXMuc3ZnQ29udGFpbmVyU2l6ZSgpO1xuICB9XG5cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXNjcmlwdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBhIGFsdHVyYSBkbyBnYXVnZS5cbiAgICpcbiAgICogTyB2YWxvciBtw61uaW1vIGFjZWl0byDDqSAzMDBweC5cbiAgICpcbiAgICogQGRlZmF1bHQgYDMwMHB4YFxuICAgKi9cbiAgQElucHV0KCdwLWhlaWdodCcpIHNldCBoZWlnaHQodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuc2V0R2F1Z2VIZWlnaHQodmFsdWUpO1xuICAgIHRoaXMuc3ZnQ29udGFpbmVyU2l6ZSgpO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEZWZpbmnDp8OjbyBwYXJhIG8gYWxjYW5jZSBkZSBjb3Jlcy4gQW8gYWRpY2lvbmFyIHBlbG8gbWVub3MgdW0gaXRlbSBuYSBsaXN0YSxcbiAgICogaW5jb3Jwb3JhLXNlIG8gcG9udGVpcm8gcXVlIGFzc2luYWxhIG8gdmFsb3IgcGFzc2FkbyBlbSBgcC12YWx1ZWAuXG4gICAqIFNlIG8gdmFsb3IgZGUgYHAtdmFsdWVgIGZvciBpbmZlcmlvciBhbyBtw61uaW1vIHZhbG9yIGRlZmluaWRvIGVtIGBQb0dhdWdlUmFuZ2VzLmZyb21gLCBvIGRvbcOtbmlvIG3DrW5pbW8gZG8gZ2F1Z2Ugc2Vyw6EgYHAtdmFsdWVgLlxuICAgKiBBIG1lc21hIHJlZ3JhIHByZXZhbGVjZSBwYXJhIHZhbG9yZXMgbcOheGltb3MuXG4gICAqL1xuICBASW5wdXQoJ3AtcmFuZ2VzJykgc2V0IHJhbmdlcyh2YWx1ZTogQXJyYXk8UG9HYXVnZVJhbmdlcz4pIHtcbiAgICB0aGlzLl9yYW5nZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHRoaXMudmVyaWZ5Q29sb3JzKHZhbHVlKSA6IFtdO1xuICAgIHRoaXMuc3ZnQ29udGFpbmVyU2l6ZSgpO1xuICB9XG5cbiAgZ2V0IHJhbmdlcygpOiBBcnJheTxQb0dhdWdlUmFuZ2VzPiB7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBvIHTDrXR1bG8gZG8gZ2F1Z2UuXG4gICAqL1xuICBASW5wdXQoJ3AtdGl0bGUnKSBzZXQgdGl0bGUodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX3RpdGxlID0gdmFsdWU7XG5cbiAgICB0aGlzLnN2Z0NvbnRhaW5lclNpemUoKTtcbiAgfVxuXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGl0bGU7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBWYWxvciByZWZlcmVudGUgYW8gdmFsb3IgZGEgc8OpcmllLiBTZXUgY29tcG9ydGFtZW50byBzZWd1ZSBhIHNlZ3VpbnRlcyByZWdyYXM6XG4gICAqXG4gICAqIC0gU2VtIGBwLXJhbmdlc2A6IE9zIHZhbG9yZXMgcGFzc2Fkb3MgcGFyYSBgcC12YWx1ZWAgZSBgcC1kZXNjcmlwdGlvbmAgc2Vyw6NvIGNlbnRyYWxpemFkb3Mgbm8gaW50ZXJpb3IgZG8gYXJjby5cbiAgICogQSBiYXNlIGRvIHZhbG9yIHNlcsOhIHBlcmNlbnR1YWwgdGVuZG8gY29tbyBiYXNlIG9zIGFsY2FuY2VzIGVudHJlIHplcm8gZSAxMDAlLiBTZSBwYXNzYWRvIHVtIHZhbG9yIHN1cGVyaW9yIGEgMTAwLFxuICAgKiBBIGNvbG9yaXphw6fDo28gZG8gZ2F1Z2Ugc2Vyw6EgY29tcGxldGEgZSBvIHZhbG9yIHBhc3NhZG8gc2Vyw6EgZXhpYmlkbyBubyBpbnRlcmlvciBkbyBhcmNvLlxuICAgKiAtIENvbSBgcC1yYW5nZXNgOiBBIGRlc2NyacOnw6NvIHNlcsOhIGV4aWJpZGEgYWNpbWEgZG8gZ2F1Z2UgZSBoYXZlcsOhIHVtIHBvbnRlaXJvIG1hcmNhbmRvIG8gdmFsb3IgcGFzc2FkbyBlbSBgcC12YWx1ZWAuXG4gICAqIENvbnNpZGVyYW5kbyBxdWUgbyBhbGNhbmNlIGVtIGByYW5nZXNgIMOpIGFiZXJ0bywgZW50w6NvIGEgZXNjYWxhIGRlIGBwLXZhbHVlYCBzZXLDoSBlbSByZWxhw6fDo28gYW8gbWVub3IvbWFpb3IgYWxjYW5jZVxuICAgKiBhYnNvbHV0byBkZWZpbmlkbyBlbSBgcC1yYW5nZXNgLlxuICAgKiBTZSBwYXNzYWRvIHVtIGBwLXZhbHVlYCBpbmZlcmlvciBlbSByZWxhw6fDo28gYW8gbcOtbmltbyB2YWxvciBkZWZpbmlkbyBlbSBgcC1yYW5nZXNgLCBvIGRvbcOtbmlvIG3DrW5pbW8gZG8gZ2F1Z2UgcGFydGlyw6EgZGUgYHAtdmFsdWVgLlxuICAgKiBBIG1lc21hIHJlZ3JhIHByZXZhbGVjZSBwYXJhIHZhbG9yZXMgbcOheGltb3MuXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ3AtdmFsdWUnKSBzZXQgdmFsdWUoZ2F1Z2VWYWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnYXVnZVZhbHVlID09PSAnbnVtYmVyJyB8fCAodHlwZW9mIGdhdWdlVmFsdWUgPT09ICdzdHJpbmcnICYmICg8c3RyaW5nPmdhdWdlVmFsdWUpLnRyaW0oKSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gIWlzTmFOKGdhdWdlVmFsdWUpID8gTnVtYmVyKGdhdWdlVmFsdWUpIDogdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBnZXQgdmFsdWUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY29sb3JTZXJ2aWNlOiBQb0NvbG9yU2VydmljZSkge31cblxuICBwcml2YXRlIHZlcmlmeUNvbG9ycyhyYW5nZXM6IEFycmF5PFBvR2F1Z2VSYW5nZXM+KSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3JTZXJ2aWNlLmdldENvbG9yczxQb0dhdWdlUmFuZ2VzPihyYW5nZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRHYXVnZUhlaWdodChoZWlnaHQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgZ2F1Z2VIZWlnaHQgPSBjb252ZXJ0VG9JbnQoaGVpZ2h0KTtcblxuICAgIHJldHVybiBnYXVnZUhlaWdodCAmJiBnYXVnZUhlaWdodCA+IHBvR2F1Z2VNaW5IZWlnaHQgPyBnYXVnZUhlaWdodCA6IHBvR2F1Z2VNaW5IZWlnaHQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc3ZnQ29udGFpbmVyU2l6ZSgpOiB2b2lkO1xufVxuIl19